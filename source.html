<canvas id=a><script>

// Var reference:
// a = canvas
// b = blur function
// c = context
// d = image data
// e = generation function
// I = convert coords function.
// g = Get offset function
// h = ImageData.data
// i = iterator
// j = general use
// k =
// l = map array
// m =
// n = iterator
// o = iterator
// p =
// q =
// r = render function
// s = Math
// t = Math.random
// u =
// v = half-width of the map
// w = width of the map
// x = coord
// y = coord
// z = coord

// Constants.
s=Math;
t=s.random;
w=510;		// Size of map.
v=w/2;		// Size of math / 2.

// Create canvas/context/imagedata.
c=a.getContext("2d");
d=c.createImageData(a.width=w,a.height=v);		// Titled view.
h=d.data;

// Create map.
l=Array(w*w).fill(0);

// Convert coords to I.
I=(x,y)=>x+y*w;

// Get a random offset (-1, 0, 1).
g=()=>~~(t()*3)-1;

// Increment a point on the map.
ap=(x,y)=>l[I(x,y)]++;

// Generate map by repeating above function, repositioned each time.
e=n=>{
	x=y=v;
	while(n--){
		u=x-v;
		j=y-v;
		if(u*u+j*j>v*v*.9){
			j=t()*s.PI;
			x=v+~~(s.cos(j)*v/2);
			y=v+~~(s.sin(j)*v/2);
		}
		ap(x+=g(),y+=g());
	}
}

// Simple blur function.
// Not accurate, in the sense that there's no horizontal bounds checking.
// It just doesn't cause any problems in this use case.
b=n=>{
	while(n--){
		i=w*w-w;
		while(i-->w){
			l[i]=(l[i]+l[i-1]+l[i+1]+l[i-w]+l[i+w])/5;
		}
	}
}

// Render function.
r=()=>{
	h.fill(v);
	mx=255/l.reduce((a,b)=>s.max(a,b));
	x=w;
	while(x--){
		y=0;
		while(y<w){
			i=I(x,y);
			z=l[i]*mx;

			// Shadows.
			sh=.7+(l[i-w-1]*mx-z)/30;

			// Noise/
			o = s.sin((y+x*y)*x*y);

			// Water.
			m = (z<50)
				?[100+z*o,150+o*5+z,235-z]

			// Beach.
			:(z<60)
				?m = [240, 240, 180]

			// Trees.
			:(z<150&&z>90&&o>.5)
				?(z+=20*o,[76+o*23, 135+o*29, 52+o*13])


			// Grass.
			:(z<150)
				?[129+o*3, 226+o*9, 90+o*3]

			// Mountain-side.
			:(z<220)
				?[200+o*9, 220+o*5, 200+o*9]

			// Mountain-top.
			:[v,v,v];

			m[0]*=sh;
			m[1]*=sh;
			m[2]*=sh;

			//
			z = ~~(y - z*z/1e3);
			do {
				if(z>=0)
					h.set(m,I(x,~~(z/2))*4)
			} while (y>z++);

			//
			y++;
		}
	}
}

e(1e6);
b(50);
r();

d=c.createImageData(a.width=w,a.height=v);
k=d.data;
p=l;
l=Array(w*w).fill(0);

// Modify the color of a pixel at "X"/"Y" by "_"
Y=(X,Y,_)=>{
	for(n=3;n--;)
		k[I(X,Y)*4+n]+=_
};

// Clouds.
e(1e5);
b(50);
xp=0;
setInterval(()=>{
	xp-=1;
	k.set(h,0);
	nx=255/l.reduce((a,b)=>s.max(a,b));
	x=w;
	while(x--){
		y=w;
		while(y--){

			// Water animation
			z=p[I(x,y)]*mx;
			i=I(x,~~(y/2-2))*4;
			if (z<30){
				k[i+1]+=s.sin(y/5-xp/8)+s.cos((x+y)/5-xp/8);;
			}

			// Shore wave animation
			sin=s.sin(y/9-xp/4);
			if (z<53+sin&&z>=30+sin){
				Y(x,~~(y/2-2),z-25)
			}

			i=I(x,y);
			z=l[i]*nx/3;

			// Cloud.
			Y(x-xp,~~(y/2),-z/3)	// Shadow.
			Y(x+99-xp,~~(y/2)-50,z) // Body.
		}
	}
	c.putImageData(d,0,0);
},40);

</script>
