<canvas id=a><script>

// Var reference:
// a = canvas
// b = blur function
// c = context
// d = image data
// e = generation function
// f = 255;
// g = Get offset function
// h =
// i = iterator
// j = general use
// k =
// l = map array
// m =
// n = iterator
// o = iterator
// p =
// q =
// r = render function
// s = Math
// t = Math.random
// u =
// v = half-width of the map
// w = width of the map
// x = coord
// y = coord
// z = coord

// Constants.
s=Math;
t=s.random;
f=255;
w=500;		// Size of map.
v=w/2;		// Size of math / 2.

// Create canvas/context/imagedata.
c=a.getContext("2d");
d=c.createImageData(a.width=w,a.height=v);		// Titled view.

// Create map.
l=Array(w*w).fill(0);

// Convert coords to id.
id=(x,y)=>x+y*w;

// Get a random offset (-1, 0, 1).
g=()=>~~(t()*3)-1;

// Increment a point on the map.
ap=(x,y)=>l[id(x,y)]++;

// Generate map by repeating above function, repositioned each time.
e=(n)=>{
	x=y=v;
	while(n--){
		u=x-v;
		j=y-v;
		if(u*u+j*j>v*v*.9){
			j=t()*s.PI;
			x=v+~~(s.cos(j)*v/2);
			y=v+~~(s.sin(j)*v/2);
		}
		ap(x+=g(),y+=g());
	}
}

// Simple blur function.
// Not accurate, in the sense that there's no horizontal bounds checking.
// It just doesn't cause any problems in this use case.
b=(n)=>{
	while(n--){
		i=w*w-w;
		while(i-->w){
			l[i]=(l[i]+l[i-1]+l[i+1]+l[i-w]+l[i+w])/5;
		}
	}
}

// Render function.
r=()=>{
	mx=l.reduce((a,b)=>s.max(a,b));
	mx=255/mx;
	x=w;
	while(x--){
		y=0;
		while(y<w){
			i=id(x,y);
			z=l[i]*mx;

			// Shadows.
			sh=.7+(l[i-w-1]*mx-z)/30;

			// Noise/
			o = s.sin((y+x*y)*x*y);

			// Water.
			m = (z<50)
				?[100+z*o,150+o*5+z,235-z,f]

			// Beach.
			:(z<60)
				?m = [240, 240, 180,f]

			// Trees.
			:(z<150&&z>90&&o>.5)
				?(z+=20*o,[76+o*23, 135+o*29, 52+o*13,f])


			// Grass.
			:(z<150)
				?[129+o*3, 226+o*9, 90+o*3,f]

			// Mountain-side.
			:(z<220)
				?[200+o*9, 220+o*5, 200+o*9,f]

			// Mountain-top.
			:[f,f,f,f];

			m[0]*=sh;
			m[1]*=sh;
			m[2]*=sh;

			//
			z = ~~(y - z*z/1e3);
			do {
				if(z>=0)
					d.data.set(m,id(x,~~(z/2))*4)
			} while (y>z++);

			//
			y++;
		}
	}
}

e(1e6);
b(50);
r();
h=l;
k=d;
d=c.createImageData(a.width=w,a.height=v);		// Titled view.
l=Array(w*w).fill(0);

// Clouds.
e(1e5);
b(50);
xp=0;
setInterval(()=>{
	xp-=1;
	d.data.set(k.data,0)
	mx=l.reduce((a,b)=>s.max(a,b));
	mx=255/mx;
	x=w;
	while(x--){
		y=0;
		while(y<w){
			i=id(x,y);
			z=l[i]*mx/3;

			i=id(x-xp,~~(y/2))*4;
			d.data[i]-=z/3;
			d.data[i+1]-=z/3;
			d.data[i+2]-=z/3;

			i=id(x+150-xp,~~(y/2)-100)*4;
			d.data[i]+=z;
			d.data[i+1]+=z;
			d.data[i+2]+=z;

			//
			y++;
		}
	}
	c.putImageData(d,0,0);
},40);

</script>
